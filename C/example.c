/*
 * Copyright (C) 2019 Dream Property GmbH, Germany
 *                    https://dreambox.de/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <assert.h>
#include <fcntl.h>
#include <stdbool.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/random.h>
#include <unistd.h>

#include <openssl/bn.h>
#include <openssl/err.h>
#include <openssl/sha.h>
#include <openssl/x509_vfy.h>

#include "random.h"
#include "tpm_crypt.h"
#include "tpmd_socket.h"

static const unsigned char tpm_root_mod[128] = {
	0x9F,0x7C,0xE4,0x47,0xC9,0xB4,0xF4,0x23,0x26,0xCE,0xB3,0xFE,0xDA,0xC9,0x55,0x60,
	0xD8,0x8C,0x73,0x6F,0x90,0x9B,0x5C,0x62,0xC0,0x89,0xD1,0x8C,0x9E,0x4A,0x54,0xC5,
	0x58,0xA1,0xB8,0x13,0x35,0x45,0x02,0xC9,0xB2,0xE6,0x74,0x89,0xDE,0xCD,0x9D,0x11,
	0xDD,0xC7,0xF4,0xE4,0xE4,0xBC,0xDB,0x9C,0xEA,0x7D,0xAD,0xDA,0x74,0x72,0x9B,0xDC,
	0xBC,0x18,0x33,0xE7,0xAF,0x7C,0xAE,0x0C,0xE3,0xB5,0x84,0x8D,0x0D,0x8D,0x9D,0x32,
	0xD0,0xCE,0xD5,0x71,0x09,0x84,0x63,0xA8,0x29,0x99,0xDC,0x3C,0x22,0x78,0xE8,0x87,
	0x8F,0x02,0x3B,0x53,0x6D,0xD5,0xF0,0xA3,0x5F,0xB7,0x54,0x09,0xDE,0xA7,0xF1,0xC9,
	0xAE,0x8A,0xD7,0xD2,0xCF,0xB2,0x2E,0x13,0xFB,0xAC,0x6A,0xDF,0xB1,0x1D,0x3A,0x3F,
};

static bool verify_signature_v1(const struct buffer *ica,
                                const struct buffer *leaf,
                                const struct buffer *signature,
                                const struct buffer *plaintext)
{
	unsigned char ica_mod[128];
	unsigned char leaf_mod[128];
	unsigned char buf[128];

	if (plaintext == NULL || plaintext->size != 8) {
		fprintf(stderr, "Invalid plaintext\n");
		return false;
	}
	if (signature == NULL || signature->size != 128) {
		fprintf(stderr, "Invalid signature\n");
		return false;
	}

	if (!(ica && tpm_validate_cert(ica_mod, ica->data, ica->size, tpm_root_mod))) {
		fprintf(stderr, "Failed to verify intermediate CA\n");
		return false;
	}
	if (!(leaf && tpm_validate_cert(leaf_mod, leaf->data, leaf->size, ica_mod))) {
		fprintf(stderr, "Failed to verify leaf certificate!\n");
		return false;
	}
	if (!tpm_decrypt(buf, signature->data, signature->size, leaf_mod)) {
		fprintf(stderr, "Could not decrypt signed block\n");
		return false;
	}
	if (memcmp(&buf[80], plaintext->data, plaintext->size)) {
		fprintf(stderr, "Challenge does not match\n");
		return false;
	}

	return true;
}

static const unsigned char tpm2_root_cert[] = {
	0x30,0x82,0x01,0xe3,0x30,0x82,0x01,0x88,0xa0,0x03,0x02,0x01,0x02,0x02,0x09,0x00,
	0xf9,0x69,0x77,0x65,0xb2,0x2b,0x72,0xb8,0x30,0x0a,0x06,0x08,0x2a,0x86,0x48,0xce,
	0x3d,0x04,0x03,0x02,0x30,0x44,0x31,0x0b,0x30,0x09,0x06,0x03,0x55,0x04,0x06,0x13,
	0x02,0x44,0x45,0x31,0x1c,0x30,0x1a,0x06,0x03,0x55,0x04,0x0a,0x0c,0x13,0x44,0x72,
	0x65,0x61,0x6d,0x20,0x50,0x72,0x6f,0x70,0x65,0x72,0x74,0x79,0x20,0x47,0x6d,0x62,
	0x48,0x31,0x17,0x30,0x15,0x06,0x03,0x55,0x04,0x03,0x0c,0x0e,0x44,0x52,0x31,0x30,
	0x30,0x30,0x20,0x52,0x6f,0x6f,0x74,0x20,0x43,0x41,0x30,0x1e,0x17,0x0d,0x31,0x38,
	0x31,0x31,0x31,0x35,0x32,0x32,0x32,0x37,0x34,0x33,0x5a,0x17,0x0d,0x33,0x38,0x31,
	0x31,0x31,0x30,0x32,0x32,0x32,0x37,0x34,0x33,0x5a,0x30,0x44,0x31,0x0b,0x30,0x09,
	0x06,0x03,0x55,0x04,0x06,0x13,0x02,0x44,0x45,0x31,0x1c,0x30,0x1a,0x06,0x03,0x55,
	0x04,0x0a,0x0c,0x13,0x44,0x72,0x65,0x61,0x6d,0x20,0x50,0x72,0x6f,0x70,0x65,0x72,
	0x74,0x79,0x20,0x47,0x6d,0x62,0x48,0x31,0x17,0x30,0x15,0x06,0x03,0x55,0x04,0x03,
	0x0c,0x0e,0x44,0x52,0x31,0x30,0x30,0x30,0x20,0x52,0x6f,0x6f,0x74,0x20,0x43,0x41,
	0x30,0x59,0x30,0x13,0x06,0x07,0x2a,0x86,0x48,0xce,0x3d,0x02,0x01,0x06,0x08,0x2a,
	0x86,0x48,0xce,0x3d,0x03,0x01,0x07,0x03,0x42,0x00,0x04,0x11,0xdd,0x96,0xa2,0x1d,
	0x73,0x13,0xad,0xc4,0x97,0xdb,0x97,0x78,0x61,0x43,0x59,0x02,0xb9,0xeb,0x26,0xf5,
	0xe2,0xd7,0x50,0x62,0x76,0x4b,0xb8,0xbd,0x5f,0x5b,0x98,0xc9,0x02,0xcb,0xf2,0xe5,
	0x02,0x4f,0xc8,0x77,0x8d,0x97,0x9a,0x86,0xc3,0x10,0x1b,0x26,0xde,0xf9,0x6e,0x14,
	0xef,0x3f,0x0e,0x00,0x54,0x74,0x79,0x97,0x2f,0x77,0x9d,0xa3,0x63,0x30,0x61,0x30,
	0x1d,0x06,0x03,0x55,0x1d,0x0e,0x04,0x16,0x04,0x14,0xab,0xd0,0x17,0xb3,0xbb,0x4f,
	0x18,0x5f,0x14,0x7b,0xfb,0xff,0x0f,0x60,0x9f,0x75,0x09,0xca,0x12,0x15,0x30,0x1f,
	0x06,0x03,0x55,0x1d,0x23,0x04,0x18,0x30,0x16,0x80,0x14,0xab,0xd0,0x17,0xb3,0xbb,
	0x4f,0x18,0x5f,0x14,0x7b,0xfb,0xff,0x0f,0x60,0x9f,0x75,0x09,0xca,0x12,0x15,0x30,
	0x0f,0x06,0x03,0x55,0x1d,0x13,0x01,0x01,0xff,0x04,0x05,0x30,0x03,0x01,0x01,0xff,
	0x30,0x0e,0x06,0x03,0x55,0x1d,0x0f,0x01,0x01,0xff,0x04,0x04,0x03,0x02,0x01,0x86,
	0x30,0x0a,0x06,0x08,0x2a,0x86,0x48,0xce,0x3d,0x04,0x03,0x02,0x03,0x49,0x00,0x30,
	0x46,0x02,0x21,0x00,0xef,0x91,0x24,0x6f,0x0e,0x57,0x38,0xb7,0xba,0x77,0xd7,0xb4,
	0xe6,0x2f,0xd2,0x7f,0xe5,0x7e,0xeb,0x97,0xec,0x33,0xa2,0x50,0x6d,0x95,0x7e,0xc6,
	0x34,0x50,0x40,0xf9,0x02,0x21,0x00,0xba,0x3f,0xc7,0xc0,0x6e,0x1a,0xf2,0x85,0xae,
	0xd8,0x87,0x32,0x64,0x9b,0x73,0x42,0x8c,0x0a,0xe7,0xcc,0xdc,0xd3,0x35,0x10,0x7e,
	0x04,0x1f,0xff,0x30,0xca,0x33,0xc9
};

static bool verify_signature_v2(const struct buffer *ica,
                                const struct buffer *leaf,
                                const struct buffer *signature,
                                const struct buffer *plaintext)
{
	const unsigned char *ptr, *r, *s;
	EVP_MD_CTX *mdctx;
	EVP_PKEY *pkey;
	X509 *cert;
	int ret = 0;

	if (!(plaintext && plaintext->size >= 8 && plaintext->size <= 32)) {
		fprintf(stderr, "Invalid plaintext!\n");
		return false;
	}
	if (!(signature && signature->size == 64)) {
		fprintf(stderr, "Invalid signature!\n");
		return false;
	}
	if (!(ica && leaf)) {
		fprintf(stderr, "No certificates available\n");
		return false;
	}

	if (!tpm2_validate_cert(tpm2_root_cert, sizeof(tpm2_root_cert),
	                        ica->data, ica->size,
	                        leaf->data, leaf->size)) {
		fprintf(stderr, "Failed to verify certificates\n");
		return false;
	}

	ptr = leaf->data;
	cert = d2i_X509(NULL, &ptr, leaf->size);
	if (cert == NULL)
		return false;

	r = &signature->data[0];
	s = &signature->data[32];

	pkey = X509_get_pubkey(cert);
	X509_free(cert);

	unsigned char buf[1024];
	unsigned int pos = 0;
	buf[pos++] = 0x30;
	buf[pos++] = (2 + 32) * 2 + (r[0] >> 7) + (s[0] >> 7);

	buf[pos++] = 0x02;
	if (r[0] >= 0x80) {
		buf[pos++] = 33;
		buf[pos++] = 0;
	} else {
		buf[pos++] = 32;
	}

	memcpy(&buf[pos], r, 32);
	pos += 32;

	buf[pos++] = 0x02;
	if (s[0] >= 0x80) {
		buf[pos++] = 33;
		buf[pos++] = 0;
	} else {
		buf[pos++] = 32;
	}

	memcpy(&buf[pos], s, 32);
	pos += 32;

	mdctx = EVP_MD_CTX_create();
	if (mdctx == NULL)
		goto free_pkey;

	ret = EVP_DigestVerifyInit(mdctx, NULL, EVP_sha256(), NULL, pkey);
	if (ret != 1)
		goto destroy_ctx;

	ret = EVP_DigestVerifyUpdate(mdctx, plaintext->data, plaintext->size);
	if (ret != 1)
		goto destroy_ctx;

	ret = EVP_DigestVerifyFinal(mdctx, buf, pos);

destroy_ctx:
	EVP_MD_CTX_destroy(mdctx);
free_pkey:
	EVP_PKEY_free(pkey);

	return ret == 1;
}

static bool read_random_data(struct buffer **dest, size_t count)
{
	const size_t random_bin_size = &_binary_random_bin_end - &_binary_random_bin_start;
	int fd;
	ssize_t ret;
	unsigned char buf[count];
	unsigned char rng1[count];
	unsigned char rng2[count];
	struct timespec tv;
	pid_t pid;
	size_t i;

	/* We combine two different sources of usually good random data.
           This may seem odd at first, because the underlying source is likely
	   the same for both, but we observed maliciously patched kernels in
	   the past. */

	do {
		if (getrandom(rng1, count, 0) < 0) {
			perror("getrandom");
			return false;
		}

		fd = open("/dev/urandom", O_RDONLY);
		if (fd < 0) {
			perror("/dev/urandom");
			return false;
		}
		ret = read(fd, rng2, count);
		if (ret != (ssize_t)count) {
			perror("read");
			close(fd);
			return false;
		}
		close(fd);

	} while (memcmp(rng1, rng2, count) == 0);

	/* As we can't trust the kernel alone, we add some buildtime and
	   runtime seed below and add in uninitialized bytes from the stack. */

	clock_gettime(CLOCK_MONOTONIC, &tv);
	pid = getpid();

	for (i = 0; i < count; i++) {
		buf[i] ^= rng1[i];
		buf[i] ^= rng2[i];
		buf[i] ^= ((unsigned char *)&_binary_random_bin_start)[i % random_bin_size];
		buf[i] ^= ((unsigned char *)&pid)[i % sizeof(pid)];
		buf[i] ^= ((unsigned char *)&tv.tv_sec)[i % sizeof(tv.tv_sec)];
		buf[i] ^= ((unsigned char *)&tv.tv_nsec)[i % sizeof(tv.tv_nsec)];
	}

	buffer_copy(dest, buf, count);
	return true;
}

int main(void)
{
	struct tpmd_context *ctx;
	struct buffer *ica = NULL;
	struct buffer *leaf = NULL;
	struct buffer *random = NULL;
	struct buffer *signature = NULL;
	bool verified = false;

	ctx = tpmd_connect();
	if (ctx == NULL) {
		fprintf(stderr, "Failed to connect to tpmd: %m\n");
		return EXIT_FAILURE;
	}

	if (!tpmd_read_certificates(ctx, &ica, &leaf)) {
		fprintf(stderr, "Failed to read certificates: %m\n");
		goto out;
	}

	if (!read_random_data(&random, tpmd_get_signature_size(ctx))) {
		fprintf(stderr, "Could not read random data: %m\n");
		goto out;
	}

	if (!tpmd_compute_signature(ctx, random, &signature)) {
		fprintf(stderr, "Failed to compute signature: %m\n");
		goto out;
	}

	if (tpmd_get_generation(ctx) == 1)
		verified = verify_signature_v1(ica, leaf, signature, random);
	else
		verified = verify_signature_v2(ica, leaf, signature, random);

out:
	tpmd_disconnect(ctx);

	free(signature);
	free(random);
	free(leaf);
	free(ica);

	if (verified == true) {
		printf("Signature OK\n");
		return EXIT_SUCCESS;
	}

	fprintf(stderr, "Signature verification failed!\n");
	return EXIT_FAILURE;
}
